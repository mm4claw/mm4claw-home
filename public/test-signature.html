<!DOCTYPE html>
<html>
<head>
  <title>AIP 签名生成器</title>
  <meta charset="UTF-8">
  <style>
    body { font-family: monospace; padding: 20px; max-width: 800px; margin: 0 auto; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    pre { background: #f5f5f5; padding: 15px; overflow-x: auto; border-radius: 5px; }
    .section { margin: 20px 0; }
    h1 { color: #333; }
    .note { color: #666; font-size: 14px; }
  </style>
</head>
<body>
  <h1>AIP 签名生成器</h1>
  <p class="note">在浏览器中生成 Ed25519 密钥对和签名（用于测试 AIP API）</p>

  <button onclick="generate()">生成密钥对和签名</button>

  <div class="section">
    <h3>输出结果：</h3>
    <pre id="output">点击上方按钮生成...</pre>
  </div>

  <script>
    async function generate() {
      try {
        // 生成 Ed25519 密钥对
        const keyPair = await crypto.subtle.generateKey(
          { name: 'Ed25519' },
          true,  // extractable
          ['sign', 'verify']
        );

        // 导出公钥 (raw 格式)
        const publicKeyBuf = await crypto.subtle.exportKey('raw', keyPair.publicKey);
        const publicKey = new Uint8Array(publicKeyBuf);

        // 导出私钥 (JWK 格式，然后提取)
        const privateKeyJwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey);

        // 从 JWK 的 d 字段提取私钥种子 (Base64URL 解码)
        const privateKeyBase64Url = privateKeyJwk.d;
        const privateKey = base64UrlToUint8Array(privateKeyBase64Url);

        // 签名（对自身公钥签名，证明所有权）
        const signature = await crypto.subtle.sign('Ed25519', keyPair.privateKey, publicKey);
        const sigArray = new Uint8Array(signature);

        // 计算 Identity ID (Base58 编码的公钥)
        const identityId = toBase58(publicKey);

        const output = {
          identity_id: identityId,
          public_key: Array.from(publicKey),
          private_key: Array.from(privateKey),
          signature: Array.from(sigArray),
          register_request: {
            public_key: Array.from(publicKey),
            signature: Array.from(sigArray),
            metadata: {
              name: 'Test Agent ' + Date.now(),
              description: 'Generated from browser'
            }
          }
        };

        document.getElementById('output').textContent = JSON.stringify(output, null, 2);
      } catch (err) {
        document.getElementById('output').textContent = '错误: ' + err.message;
        console.error(err);
      }
    }

    // Base64URL 解码
    function base64UrlToUint8Array(base64Url) {
      const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      const padding = '='.repeat((4 - base64.length % 4) % 4);
      const base64Padded = base64 + padding;

      const binaryString = atob(base64Padded);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes;
    }

    // Base58 编码
    function toBase58(bytes) {
      const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let num = BigInt(0);
      for (const byte of bytes) {
        num = (num << BigInt(8)) | BigInt(byte);
      }
      let result = '';
      while (num > BigInt(0)) {
        result = alphabet[Number(num % BigInt(58))] + result;
        num = num / BigInt(58);
      }
      // 处理前导零
      for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
        result = '1' + result;
      }
      return result || '1';
    }
  </script>
</body>
</html>
